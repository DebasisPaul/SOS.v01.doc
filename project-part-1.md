
üôå üëç

*00-26.05 part-1*

*00:00 - 00:50 Blazor Web Assembly is a Single page app framework for building interective client side web apps with dot net. It uses open Web standard without plugin or recompiling code into other languages. This Course will teach you how to use balzor web assembly & web api on .Net 7 . We will build step by step a shopping Cart Application. We also provide the guide on how to intigrate a payment gateway into our blazor web Assembly component so that a user able to pay for products through our application using a debit or credit card or in the paypal account.  [SPA (Single-page application)](https://developer.mozilla.org/en-US/docs/Glossary/SPA)*

*Blazor is a relatively new feature of asp dot net. It offers two hosting model. A server side hosting model &  a client side hosting model. We are going to use the client side hosting model for the development of our shopping cart application. The significanse of this hosting model is that the C# code runs directly within our browsers. What makes this possible is a technology named `Web Assembly`. In recent years the creation of SPA applications or single page applications have become very popular as web solutions. Recently Javascript frameworks like Angular or React have been the avilable choices for the creation of spa applications. With Blazor we are now able to create our single page applications using C#. We don't necessaryly need to depend on  javascript for the creation of our interective UI Code.
We can create this code using C#. In this appliaction however the payment gateway provided by paypal is coded in javascript. So we will use blazor into our probality funtionality with javascript to interect with the relavent javascript paypal code. 02:08 - 03:20*

*03:20 - 04:16Add a new Blazor Web Assembly App Project. A project template for creating a Blazor app that runs on WebAssembly and is optionally hosted by an ASP.NET Core app. This template can be used for web apps with rich dynamic user interfaces (UIs)*

*Add a new ASP.NET Core Web API Project Template (A project template for creating an ASP.NET Core application with an example Controller for a RESTful HTTP service. This template can also be used for ASP.NET Core MVC Views & Controllers)*

*We Enable `OpenAPI` support. By doing this the `Swashbuckle` NuGet Package will be automatically installed & the appropriate swagger middleware will be automatically configured appropiately within our project. One of the advatages of this is when we run our Web Api project interectively we'll be able to test our web Api code through our browsers even before we've developed any front-end code. So the basic UI will automatically be created for this purpose for us. When we run our application interectevly we'll be able  to test each of our action methods through the relavent automatically created web based UI. 04:17- 05:52*

*We are going to build our database using code first migrations & entity framework core [2]. Migration allow us to evolve our database without using data or database object. So by using plain all C# classes we can build the database entites that we wish to include within our Shopping Cart Application. Once we've created relavent entity related C# classes we're look at an entity relationship diagram that represent our shopping cart application database design. 6.16 - 6.43* 

*Create Entities Related C# Clases. This is way the classes that represent out database entities will resign. [Microsoft identity platform documentation](https://docs.microsoft.com/en-us/azure/active-directory/develop/)*

*11.00- 11.41 1Entity Relatioship Diagram Link [Visit Here](https://lucid.app/lucidchart/969fa12e-1cb2-49bf-9e2d-3a89accc11ab/edit?viewport_loc=-65%2C-11%2C1707%2C872%2C0_0&invitationId=inv_534ffb26-27c6-4037-99ad-da8d6e9f0aa2#) [Database Relationships](https://www.sqlshack.com/learn-sql-types-of-relations/ https://code.tutsplus.com/articles/sql-for-beginners-part-3-database-relationships--net-8561 https://www.tutorialsteacher.com/sqlserver/tables-relations)*

*Using  ef7 to generate a database for our shopping cart application. The classes that we've just crated representing our entities will be used by ef7 to generate the corresponding database table within the database that ef7 create for us. In order to generate our database with the relavent tables through Visual Studio Let's Install two Nuget Packages, `EntityFrameworkCore.SqlServer` `EntityFrameworkCore.Tools` for running migrations within visual studio. The reason for installing `EntityFrameworkCore.Tools` this package is because we want to run our migration with in the visual studio as supposed to using .Net CLI for this purpose. We can use different commands when running migration commands using the .Net CLI. As supposed to the command we run when using Visual Studio. 11.56- 14.08 Configuring Connection String in order to connect the application with the database that we wish to create using ef7 code first migrations. 14.22- 15.20 [Connection Strings](https://docs.microsoft.com/en-us/ef/core/miscellaneous/connection-strings)*

*15.21-Create Database Context Class. So in order to make this class represant our ef7 databse context we need to implement code so that our `ShopOnlineDbContext` Class inherits from ef7 DbContext class. An red squigly line under `DbContext` this is because we've an important `Microsoft.EntityFramewokCore` Namespace. An easy way to include the appropriate using directive through visual studio is to press `Ctr+Period` & then select the appropriate menu item from the menu that is presented to us through Visual Studio. Let's Create the Constructor for our `ShopOnlineDbContext` Class. We must add a parameter to to the constructor that we've just generated. The parameter is name `Options` & is of the generic type `DbContextOptions` which has the data type `ShopOnlineDbContext` Passed as an argument to it. We can then write code to pass the argument that will be passed to our `ShopOnlineDbContext` Class Constructor to the base class from which Inherit IE. the DbContext class. Now because We want to focus on the shopping cart workflow at the stage & don't want us to distructed by the implementation of administrative CRUD operation functionality. *An Easy way to automaically generate a Constructor within visual studio is type `ctor` & then press the tab key twice. Then in order to indicate to .Net that we want an object of type ShopOnlineDbContext to be injected into this constructor only need to do is difine an parameter with in our constructor of type ShopOnlineDbContext.* [DbContext Class](https://docs.microsoft.com/en-us/dotnet/api/system.data.entity.dbcontext?view=entity-framework-6.2.0, https://docs.microsoft.com/en-us/ef/ef6/fundamentals/working-with-dbcontext) [Passing Parameters (C# Programming Guide)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/passing-parameters) [Constructors (C# programming guide)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/constructors) [Generic type parameters (C# Programming Guide)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/generic-type-parameters, https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/generics) [Inheritance in C# and .NET](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/inheritance)*

*`OnModelCreating Method Overriding`  We are going to seed our database with certain data. This is data that we already prepared. So we're not going to include Create Read Update & delete Funtionality regarding the creation & maintenance of product data. At the stage we are going to seed our database with product related data. We're going to seed our database with the relavent data so that we can move directly to the creation of our shopping cart functionality. So in order to seed database appropriately we can override a method that exist  within the DbContext based class. This method is named `OnModelCreating` An easy way to generate the relavent override code for this method through visual studio is to type in the word `override` & then press the space bar. We can Insulate The `OnModelCreating` item. From the drop down list presented in us with in visual studio. [Data Seeding](https://docs.microsoft.com/en-us/ef/core/modeling/data-seeding) [override (C# reference)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/override) [Creating and configuring a model](https://docs.microsoft.com/en-us/ef/core/modeling/)*

*19.57`Using Entity Framework Core DbSet Generic Type` So for each of our entities we need to appropriately include a public property of type `DbSet` with in our `ShopOnlineDbContext` Class. [DbSet](https://docs.microsoft.com/en-us/dotnet/api/system.data.entity.dbset?view=entity-framework-6.2.0) 20.50 `Register ShopOnlineDbContext class for Dependency Injection` Lets open the relavent program.cs file. [Dependency injection in .NET](https://docs.microsoft.com/en-us/dotnet/core/extensions/dependency-injection) [Dependency injection in ASP.NET Core](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-6.0)*

*21.22 `Generating Migration Using ef7` Open NuGet Package Manager Console Window. Follow with this Command `Add-Migration InitiaCreate` ShopOnline Api project Set as Startup Project. By generating this migration class this code generate our database & the relavent table. This method also contain code that seeds the relavent database table with the data that prepared prair to create in this project.*

*23.47 `To run migration type update-database Command in Nuget PM console Window.` Check SSMS 19 Prev 2. We can see that the ShopOnline Database has been Created. The database table have been appropriately created based on the entities we created using C# classes. The relavent database tables have been seeded with the data created from the code we included with in the `OnModelCreating` method. Which was search with in the `ShopOnlineDbContext` class. The data with which we've seeded our database contains product & User Information. This is been done. so that we can focus on the shopping cart functionality & not worried  at this stage about implementing code `Creat Read Update & Delete` Functionality regrading products sold by our frictional online store.*

*24.56 `Running Migrations Notes:` if u have one migration or more than one migration & not happy with the changes made to the database u can undo the changes made by running this command `update-database 0` The number Zero is a special case that means before the first migration & causes the effects of all migration to be rolled back. To Remove migration run this command `remove-migration` if you Upadate a database with multiple migrations Like `Migration1 or Migration2 or Migration3 or Migration4 or Migration5`. if u wish to rollback the changes to before a particular migration was run you can Rollback your changes to that particular state by running the migration that was run directly before the migration that back contain the changes you wish to roll back `update-database Migration2`*

*26.05 - 57.45 part-2*

*26.05 `Retrieving Product data from database & Returning data to client blazor component` This is the second part in a series of project dedicated to building a shopping cart application using blazor & Restful web api. In this part we're going to start with the workflow that involved retieving product data from our database & returning the data to the client blazor component. The code for this functionality will be implemented with in the web api component. So in this part we're start to `develop our web api` component. Before we do this let's create the classes that represant the data that will be passed between the web api component & the blazor component. [Diagram](https://lucid.app/lucidchart/4715f825-77f7-4867-bf6d-0b9c9961cf0f/edit?viewport_loc=-10%2C-11%2C1707%2C872%2C0_0&invitationId=inv_02814206-a40a-4c94-9087-ab773e457b69#) Might be thinking but we've already created the classes that represant the data for our application, For Example Product, ProductCategory, Cart, CartItem Ext. Yes we did create this classes that represant our entities in the previous part of this project. This entity classes directly map to the database tables that we generated when we ran the relavent migrations. The function of this classes can be seed as blue prints for the correspondent database tables. When we passed data between the web api component & the blazor component we dont necessarly want to passed the exat data to find by the property in the classes that represant the database entities. For example in this project we're going to create code that returns the product data from the web api component to the blazor component. The product class contains certain product related properties one of which is the CategoryId. A particualr categoryId vlue could for example to note that a particular product falls under the electronics category & could for example be a laptop or for a example the product could for under the furniture category & clould be for example a couse. The categoryId property with in the product entity is a foreign key from the product category entity. From a human respective the categoryId property does not have much meaning because of contains a numeric value so it would for example make might sense to display the categoryId to the user we may want to pass the relavent CategoryName in adition to the product information define in the product class. So to facilitate this we can create a new model  that contains all the relavent product data as well as the relavant CategoryName which include in the product category entity & not the product entity. So make sense to create a new model to represant the data that in this case we wish to pass from server to client we need a model that includes all the product information as well as the CategoryName. The type of model i'm referring to is nate as a `DTO` or data transfer object.* 

*29.22`Create Data Transfer Object (DTO) Model` This type of model includes the data that needs to be passed between server & client. So a DTO is an object that defines how the data will be send over the network. Because that represant our entities that we create earlier directly maped to our crrespondent database table. This classes represant the structure of certain tables in our database. We can create `DTOS` data transfer objects that are based on the underline entity classes. but may be differntly shaped based on the data we needs to be passed between client & server. Now we create a standard library project to house of `dtos`.  [Data Transfer Object (DTO)](https://docs.microsoft.com/en-us/aspnet/web-api/overview/data/using-web-api-with-entity-framework/part-5 https://stackoverflow.com/questions/1051182/what-is-a-data-transfer-object-dto)*

*30.24`Create ShopOnline.Models Class Library` for creating the classes that have representingour dtos.*

*34.54`Coding The Logic for first workflow` Starting with the web api component. This workflow simply involved retrieving product data from our database & returning the data to the client blazor application. The blazor application will contain code that displays the relavent product data to the user. So ShopOnlineDbContext class has been registered for dependency injection. We'll see in a bit how we are able to implement code to ensure that an object of type ShopOnlineDbContext is injected into relavent classes.*

*35.31`Repository design Pattern Implementation to abstract data handling layout` Repositories are classes or components that Encapsulate the logic required to access data Sources. We can use repositories to centralized common data access functionality. Which has the benefit of facilitating beta maintainbility, easier Unit Testing, extensibility & Cleaner Code. The best way to Understand the repository pattern is to Implement the relavent code. So let's write the code for Product repository Funtionality. [Implementing the Repository and Unit of Work Patterns in an ASP.NET MVC Application (9 of 10)](https://docs.microsoft.com/en-us/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)
Create Interface that runs asyncronusly, Overturn Generic tasks objects. Our first method is named `get items` & returns an `IEnumerable` Collection of type Product. So a IEnumerable collection is passed as a type argument to the task object as discussed this is so the method that implement this method defination can runs asycronusly.[Asynchronous programming with async and await](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/)[Encapsulation in C#](https://dotnettutorials.net/lesson/encapsulation-csharp/) [How to define abstract properties (C# Programming Guide)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/how-to-define-abstract-properties) [IEnumerable Interface](https://docs.microsoft.com/en-us/dotnet/api/system.collections.ienumerable?view=net-6.0) [interface (C# Reference)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interface) [Task Class](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task?view=net-6.0)* 

*37.48 So we've define the interface that we want to class name ProductRepository to implement. So lets create a class directly with in the repository directory named `ProductRepository` & the first thing we need to do is write the code to implement the `IProductRepository` Interface. 39.08Visual Studio generates the relavent code stuffs for us. So Visual Studio generates default implementations for the rlavent method definations. So in this stage only want to implement the code logic relavent to the web flow that is the focus of this Project. IE returning a collection of product data to the client side calling code in this case our Blazor component. We are going to new to use the `ShopOnlineDnContext Object` to interect with our `ShopOnline Database`. As u will recall earlier we registered the `ShopOnlineDbContext object` for `dependency injection`. This means that we're able to gain access to an object of type `ShopOnlineDbContext` by defining an appropriate parameterized constructor in our pruduct repository class. [new operator (C# reference)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/new-operator) [throw (C# Reference)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/throw) [NotImplementedException Constructors](https://docs.microsoft.com/en-us/dotnet/api/system.notimplementedexception.-ctor?view=net-6.0)*

*40.04 An easy way to automatically generate constructor with in visual studio is type `ctor` & then press the tab key twice. Then in order to indicate dotnet taht we want an object `ShopOnlineDbContext` to be injected into this constructor, all we need to do is define an parameter with in our constructor of type `ShopOnlineDbContext` Lets bring in the appropriate namespace. & We can get visual studio to create an appropriate private readonly member variable to reference our ShopOnlineDbContext object by pressing `Control+Period` & Selecting the appropriate item from the list presented to us by visual studio.  [Objects - create instances of types](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/objects) [Constructors (C# programming guide)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/constructors) [Members (C# Programming Guide)
](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/members)*

*41.02so for the workflow that is the focus of this part we only need to implement code for two of the method defination with in the `iProductRepository` interface. So in this point we're only going to implement code for the `GetItems` method & the `GetCategories` method. So let implements code for `GetItems` method. All we want this method to do is returns all the products from the products table. So let's write the code for this. Note we want our code to run `asyncronusly` so we must include the `await` keyword here. Notice when we've type in the `await` keyword that the `async` keyword automatically appears in the method defination fot the `GetItems` method. If you include the await keyword with in a method. The method in which you include the await keyword must appropriately contain the async keyword. Notes that to include the `ToListasync` extension method get in our code we must bring an the `Microsoft.EntityFrameworkCore` Namespace. That's it. We've written the code to return an `IEnumerable` collection of product data from our database. So lets implement the code to return the `ProductCategories` from our database. We can do this by implementing the appropriate code with our GetCategories method. So now we've now implemented the code for retieving product data from our database. [9 Variables](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/variables) [public (C# Reference)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/public) [private (C# Reference)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/private) [readonly (C# Reference)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/readonly) [Microsoft.EntityFrameworkCore Namespace](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore?view=efcore-6.0)*

*42.56The next step is to write code `To Return the appropriate data to the Calling client` So to do this we need to create an appropriate controller class. Before we create our controller class lets delete `WeatherForecastController.cs` classes that we generated by default when we first created our web api project. This classes obviously not going to be use in our application. So now lets create a class with in our controller directory. Let's ensure that we select the appropriate controller class template. Let's name this class `ProductController`. So the first things to do is to write the code so that an object of type `ProductRepository` is automatically injected into our controller classes constructor via dependency injection. Lets also ensure that we've a read only private field that refereces the object passed in via dependency injection. But we've not yet registered our `ProductRepository` class for dependency injection. So lets write the code for this. Let's open the program.cs file. Let's implement the code to register the ProductRepository class with the dependency injection system. Notice how we use the `AddScoped` method to register our `ProductRepository` class for dependency injection. We could be use the `AddTransient` method or the `AddSingleton` method to register our `ProductRepository` class within the dependency injection system. Then in our case `AddScoped` is the appropriate method for this purpose. Very basicly using `AddTransient` would mean in that a new instance of the relavent object is provided to every class that requires the relavent object to be injected. Using `AddSingleton` Would mean have the same instance of the object injected into the relavent classes for every http request using `Add Scoped` means that the same instance of the object injected into relavent classes with in a particuar http request. Note that in this case new instance of the relavent object would be created for each http request. [Call a Web API From a .NET Client (C#)](https://docs.microsoft.com/en-us/aspnet/web-api/overview/advanced/calling-a-web-api-from-a-net-client) [Controller Class](https://docs.microsoft.com/en-us/dotnet/api/system.web.mvc.controller?view=aspnet-mvc-5.2, https://docs.microsoft.com/en-us/aspnet/mvc/overview/older-versions-1/controllers-and-routing/creating-a-controller-cs) [readonly (C# Reference)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/readonly) [System Namespace](https://docs.microsoft.com/en-us/dotnet/api/system?view=net-6.0) [ServiceCollectionServiceExtensions.AddScoped Method](https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.servicecollectionserviceextensions.addscoped?view=dotnet-plat-ext-6.0) [ServiceCollectionServiceExtensions.AddTransient Method](https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.servicecollectionserviceextensions.addtransient?view=dotnet-plat-ext-6.0) [ServiceCollectionServiceExtensions.AddSingleton Method](https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.servicecollectionserviceextensions.addsingleton?view=dotnet-plat-ext-6.0) [Objects - create instances of types](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/objects)*

*45.52`Lets Create a method defination for action method named GetItems` We want our action method to run asyncronusly. The type that is passed to the generic task object is of the generic action result type. One of the core benefits of returning an action result is that is well as returning requested data from an action method to the client and appropriate response status code can also be return. For example http status code of 200 meets the request has seeded status code of 404 represents that resource could not be found & a http status code 500 represents that an internal server error occured. So we need to pass the type of data that we wish to return to the client as a type arguments to the action results generic type. So we want to return an `iEnumerable` collection of type `ProductDto` to the client.   [Creating an Action (C#)](https://docs.microsoft.com/en-us/aspnet/mvc/overview/older-versions-1/controllers-and-routing/creating-an-action-cs) [Generic Methods (C# Programming Guide)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/generic-methods) [Generic type parameters (C# Programming Guide)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/generic-type-parameters) [Controller action return types in ASP.NET Core web API](https://docs.microsoft.com/en-us/aspnet/core/web-api/action-return-types?view=aspnetcore-6.0) [ActionResult](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.actionresult-1?view=aspnetcore-6.0) [Task](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task-1?view=net-6.0) [Action Results in Web API 2](https://docs.microsoft.com/en-us/aspnet/web-api/overview/getting-started-with-aspnet-web-api/action-results) [The HTTP status code in IIS 7.0 and later versions](https://docs.microsoft.com/en-us/troubleshoot/developer/webapps/iis/www-administration-management/http-status-code) [HTTP response status codes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#server_error_responses)*

*46.56So the first thing we need to do is create a project reference to the `ShopOnline.models` project. Because this is where our `ProductDto` class resides. Then let's bring in the `ShopOnline.Models.Dtos` namespace. Great, let's name our action method `GetItems` each action method in our controller must `map` to a particular `http verb`. For example `Get, Post, Push, Delete` etc. Our `GetItems` action method will be used for getting product data and returning that product data to the client. So the appropriate `http verb` for this action method is `Get`. So to indicate this to `dotNet` we need to decorate our `GetItems` Action method with the `HttpGet` `attribute`. So let's implement the code logic for our `GetItems` action method. Let's first create a `try-catch` block. An easy way to do this in Visual Studio is to type in `try` followed by pressing the tab key twice. So let's write code that calls the `ProductRepository` classes `GetItems` method `asysncronusly` to return an `IEnumerable` collection of type `Product` to our `Action` method. We want to `include` the `CategoryName` associated with each Product in our collection. So let's write code to `return` a collection of `ProductCategory` objects to our `Action method`. We'll write the code that `joins` our collection of `Products` with our collection of `ProductCategories` in a bit. So you may have spotted that the code in this action method is not ideal at the moment. It is not ideal because we are `Retrieving` a collection of `Products` and a collection of `Categories` in two `Separete Queries` to the database. A more performant way for retrieving the Product collection and related category data would be to appropriately use the include `Extension method` within the relavent `LINQ Queries` in the `GetItems` method within the `ProductRepository` class. The use of the `include method` would join the data retrieved from the Products database table with related data retrieved from the `ProductCategories` database table and allow for the Products data and related category data to be returned through one query. I'm going to leave the code as it is for now we'll optimize this code for performance by using the `include extension method` as i've just described toward the end of the course. So if either the product variable is null or the product categories variable is null. Let's return a status code of not found to the calling client code. So in this case our web api will return a http status code of 404 meaning that rlevant data was not found or a relavent resources was not found. So in this case it means that the client request failed and the reason for the failure is that an essential resource could not be found. Else we want to join the collection of ProductCategories with the collection of products. So that we can return a collection of `ProductsDtos` to the calling client code. Which will include the CategoryName. Remember the ProducDto definition contains a CategoryName property. In order to get the CategoryName for each product in the collection. We need to join the collection of type product to the collection of type ProductCategory. We're going to use `LINQ` for this purpose. In order to to avoid creating too many lines of code with in our action method we're going to create an extension method to return a collection type of ProductDto to our action method. So let's create a folder named `Extensions`. let's create class within our `Extensions folder` named `DtoConversions`. Note that in order to create an Extension method we need the class that houses our extesion methods to be static. Let's create our extension method. So the extension method must be a static method and we want to return an IEnumerable collection of objects of type ProductDto to the calling code. Let's name our method convert to dto. The first parameter in an extension method must be the type of an object on which we want to be able to call the conver dto extension method so by convention this parameter definition must also be preceded by this keyword. So on an IEnumerable collection of type product we want to able to call the convert to dto method in order to convert an IEnumerable collection of type product to an IEnumerable collection of type ProductDto. The logic for this method will using a link query join a collection of type product to a collection of type product category and return a collection of type product dto to the calling code. So the second parameter of the convert to dto method is of a type that is an IEnbumerable collection of type product category. Let's write logic for our extension method. So lets write a `lINQ query` that joins the collection of type product to the collection of type ProductCategory and return a collection of type ProductDto. Great so Let's go back to the product controller class and finish the code for GetItems action method. So in order for the convert to dto method to be accessible on the product variable. We must of course bring in the `ShopOnline.Api.Extensions` namespace. Then let's pass in the `ProductCategories` variable as an argument to the convert to dto extension method. Then we can return a http status code of 200 to the calling code. We can do this by returning the results of an ok method. Which accepts an argument of a collection of type ProductDto. So this code return a http status code of 200 as well as a collection of type productdto to the calling client code. So if for some reason an exception occurs during the running of the relavent server side code. In this case we want our code to return a http status code of 500 to the calling client code coupled with an appropriate error message. Let's keep the error message simple. Great so if we open our program.cs file. You can see the configuration code here related to `Swagger` and `SwaggerUI`. Swagger is an `interface description language` for describing restful apis expressed using `Json`. the configuration relevent to SwaggerUI here means that our web api project is equiped with a basic `web based user interface` where we can see relavent information regarding our `controller` and action methods. We are also able to use the swaggerUI to test and debug our action methods. When we run our web api code interactively through visual studio. So let's run our code to see this in action. And here we're presented with the SwaggerUI. Let's test our GetItems action method. We can do this through our swagger user interface like this. Excellent In the next part of this project We'll write the `calling client code` that calls the action method that we've written in this tutorial from our blazor component. We'll also write the code to appropriately display the products returned from our web api component to the user. So in the next part We'll start to develop our blazor WebAssembly Component. [HTTP request methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods) [Attributes (C#)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/attributes/) [Attribute Routing in ASP.NET Web API 2](https://docs.microsoft.com/en-us/aspnet/web-api/overview/web-api-routing-and-actions/attribute-routing-in-web-api-2) [try-catch (C# Reference)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/try-catch) [Retrieve resources in .NET apps](https://docs.microsoft.com/en-us/dotnet/core/extensions/retrieve-resources) [Introduction to LINQ Queries (C#)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/introduction-to-linq-queries) [Basic LINQ Query Operations (C#)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/basic-linq-query-operations) [Extension Methods (C# Programming Guide)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods) [EntityFrameworkQueryableExtensions.Include Method](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.entityframeworkqueryableextensions.include?view=efcore-6.0) [Query expression basics](https://docs.microsoft.com/en-us/dotnet/csharp/linq/query-expression-basics) [Jump statements (C# reference)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/jump-statements#the-return-statement) [Split queries](https://docs.microsoft.com/en-us/ef/core/querying/single-split-queries) [Efficient Querying](https://docs.microsoft.com/en-us/ef/core/performance/efficient-querying) [How to find the set difference between two lists (LINQ) (C#)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/how-to-find-the-set-difference-between-two-lists-linq) [C# program building blocks](https://docs.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/program-building-blocks) [Attributes (C#)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/attributes/) [Include(String) Method](https://docs.microsoft.com/en-us/dotnet/api/system.data.objects.objectquery-1.include?view=netframework-4.8) [Call a Web API From a .NET Client (C#)](https://docs.microsoft.com/en-us/aspnet/web-api/overview/advanced/calling-a-web-api-from-a-net-client)*

*[null (C# Reference)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/null) [Properties (C# Programming Guide)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/properties) [String.Join Method](https://docs.microsoft.com/en-us/dotnet/api/system.string.join?view=net-6.0) [Language Integrated Query (LINQ) (C#)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/) [static (C# Reference)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/static) [The C# type system](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/) [Convert Class](https://docs.microsoft.com/en-us/dotnet/api/system.convert?view=net-6.0) [How to convert a string to a number (C# Programming Guide)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/how-to-convert-a-string-to-a-number) [Exceptions and Exception Handling](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/exceptions/) [Configuration in .NET](https://docs.microsoft.com/en-us/dotnet/core/extensions/configuration) [SON serialization and deserialization (marshalling and unmarshalling) in .NET - overview](https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-overview?pivots=dotnet-6-0) [Build RESTful APIs with ASP.NET Web API](https://docs.microsoft.com/en-us/aspnet/web-api/overview/older-versions/build-restful-apis-with-aspnet-web-api) [Introduction to Microsoft Interface Definition Language 3.0](https://docs.microsoft.com/en-us/uwp/midl-3/intro) [Choose an ASP.NET Core web UI](https://docs.microsoft.com/en-us/aspnet/core/tutorials/choose-web-ui?view=aspnetcore-6.0) [Swagger UI](https://swagger.io/tools/swagger-ui/) [ASP.NET Core web API documentation with Swagger / OpenAPI](https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger?view=aspnetcore-6.0) [Walkthrough: Create and run unit tests for managed code](https://docs.microsoft.com/en-us/visualstudio/test/walkthrough-creating-and-running-unit-tests-for-managed-code?view=vs-2022) [Tutorial: Learn to debug C# code using Visual Studio](https://docs.microsoft.com/en-us/visualstudio/get-started/csharp/tutorial-debugger?view=vs-2022)* 

*Part-3*

*57.44So this is the third part of this project. Where we're building a `shopping cart application` using `blazor WebAssembly` & `Web Api`. We're building our application on .Net7. Which at the time I writing this project is the latest version of dotnet. We're now at stage where we're build our database using `ef7` `code first migrations`. & i've started implementing code for the `first workflow` which simply involved `retrieving product data` from our database & displaying this product data to the user. In part 2, the previous part of the project, we implemented the code that retrives the relavent product data from our database & returns the data to the `calling client`. This code was implemented in an `action method` within a `controller class` named `ProductController`. This class was created with in our `ShopOnline.Api` project which contains the code for our web api components.*

*58.52In this part we want to start developing the code for our `client side blazor component`. So in this part we'll implement code within our blazor component to `call the action method` that we developed in the previous part of this project and display the return data to the user. So let's get started. The first thing we need to do is copy the url to our clipboard. Which is the url of our web api component. When we run the `ShopOnline.Api` project through Visual Studio. We're doing this so that we can appropriately configure our blazor component to point the appropriate local web api url. So that we can easily test our application through visual studio during the development phase of our `shopping cart application`. One way we can access the relevant url is to run our web api project. So let's copy this part of the url which we can refer to as the `base url or base address` to our clipboards. Then let's open the `Program.cs` class within our `ShopOnline.Web` component. [Creating an Action (C#)](https://docs.microsoft.com/en-us/aspnet/mvc/overview/older-versions-1/controllers-and-routing/creating-an-action-cs) [HttpClient.BaseAddress Property](https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient.baseaddress?view=net-7.0)*

*1.00.05So here is a block of code that was automatically included within our `ShopOnline.Web` Component. Whereby the `http client object` is configured for `dependency injection`. This means that we will automatically have access to a `http client object` from appropritely written classes within our `Blazor component`. We will be using the `http client object` to call relevent `action methods` within our `web api component`. So in order for our `http client component` to point to the `web api component` on our local machines. We need to replace the `argument` that is currently being passed to the `Uri Constructor` here. With the `base URL` that we've just copied to our clipboard. So let's appropriately paste the `base url` copied to our clipboards here. Great. So we're going to wrap the `functionality` that handles `calls` to our web api component within `services`. These `services` are simply `CSharp classes` that wrap the `functionality` for handling `interections` with our `web api Component`. [HttpClient Class](https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=net-6.0) [Uri Constructors](https://docs.microsoft.com/en-us/dotnet/api/system.uri.-ctor?view=net-6.0) [Exceptions and Exception Handling](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/exceptions/) [Call a web API from ASP.NET Core Blazor](https://docs.microsoft.com/en-us/aspnet/core/blazor/call-web-api?view=aspnetcore-6.0&pivots=webassembly) [HttpClientJsonExtensions.GetFromJsonAsync Method](https://docs.microsoft.com/en-us/dotnet/api/system.net.http.json.httpclientjsonextensions.getfromjsonasync?view=net-6.0) [System.Net.Http.Json Namespace](https://docs.microsoft.com/en-us/dotnet/api/system.net.http.json?view=net-6.0) [Razor syntax reference for ASP.NET Core](https://docs.microsoft.com/en-us/aspnet/core/mvc/views/razor?view=aspnetcore-6.0) [Microsoft.AspNetCore.Components Namespace](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.components?view=aspnetcore-6.0) [ComponentBase Class](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.components.componentbase?view=aspnetcore-6.0) [ASP.NET Core Razor component lifecycle](https://docs.microsoft.com/en-us/aspnet/core/blazor/components/lifecycle?view=aspnetcore-6.0) [Blazor component](https://docs.microsoft.com/en-us/aspnet/core/blazor/components/?view=aspnetcore-6.0) [ASP.NET Web APIs](https://dotnet.microsoft.com/en-us/apps/aspnet/apis) [A web API that calls web APIs: Call an API](https://docs.microsoft.com/en-us/azure/active-directory/develop/scenario-web-api-call-api-call-api?tabs=aspnetcore) [Explore object oriented programming with classes and objects](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/classes) [C# Classes](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/classes)*

*1.01.25 So the first things to do is create a folder named `Services`. Then within the services folder let's create a folder named `Contracts`. Let's create an interface named `IPrpductService` within the Contracts folder. So We'll build up the `methods` for the product service class over time when appropriate during the development of our application. We're just going to implement code for one method in this video. So let's create a method defination for our method in the `IProductService` file. We want our method to run `Asynchronously` so our method will return a task `object`. I this case we're going to write code to return a `generic task` object. Because this method must return a value to the calling code. The type of value that we want to return to calling code is an IEnumerable collection of object of type `ProductDto`. Let's name this method `GetItems`. In a bit we'll implement code for this method to retrieve relevent product data from the appropriate action method that resides within our web api component. We've a red sqiggly line under `ProductDto`. The `ProductDto` type is defined within the `ShopOnline.Models` Project. So Let's create a project reference to the ShopOnline.Models Project. Let's then bring in the namespace for the ProductDto type. 1.03.29Great. Okay. So let's create the code to implemnt our IProductService Interface. So let's craete a class named ProductService directly within the Services folder. Let's carete a `Constructor`. So we want to tell dot net as it were that we want a http client objects. to be `injected` into our ProductService class. So to do this we simply define a parameter of type http client within our Constructor defifition. Then let's generate a `read-only member variable` to reference the object of type `http client` that will be injected into this class at `runtime`. The next things to do is to implement the `IProductService Interface`. So let's write the code for this. Let's generate the code stuff for the method that we've defined IProductService Interface. Let's write the code for the `GetItems` method. Let's first generate a `try-catch block`. Within the `try block` let's write code to call the `GetItems action method` that resides with in the `ProductController` of our web api component. 1.05.17 We're Using the `generic GetFromJsonAsync method` to call the apporipaiate action method withiin our Web Api component. We're passing in a type argument which is an IEnumerable collection of type `ProductDto` to the `GetJsonAsync Generic method`. We're doing this because we want our `GetFromJsonAsync method` to return an `IEnumerable collection of type` `ProductDto`. So this method will translate the data which will be in `Json format` returned from the web api component into an `object of type IEnumarable`, Which is `strongly typed` with the type `ProductDto`. Notice that we're passing in `texture` which denotes where the collection of resources that we want to retrieve from our web api component can be found. The web api component will know as it were to invoke the `GetItems action method` within the `ProductController class` of our web api component based on this information passed as an argument To the `GetFromJsonAsync method`. [Dependency injection in .NET](https://docs.microsoft.com/en-us/dotnet/core/extensions/dependency-injection) [.NET Runtime configuration settings](https://docs.microsoft.com/en-us/dotnet/core/runtime-config/) [try-catch (C# Reference)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/try-catch) [How to use the try/catch block to catch exceptions](https://docs.microsoft.com/en-us/dotnet/standard/exceptions/how-to-use-the-try-catch-block-to-catch-exceptions) [try-catch-finally (C# Reference)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/try-catch-finally) [HttpClientJsonExtensions.GetFromJsonAsync Method](https://docs.microsoft.com/en-us/dotnet/api/system.net.http.json.httpclientjsonextensions.getfromjsonasync?view=net-6.0) [How to serialize and deserialize (marshal and unmarshal) JSON in .NET](https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-how-to?pivots=dotnet-6-0) [Generic Methods (C# Programming Guide)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/generic-methods) [Generic classes and methods](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/generics) [Introducing JSON](https://www.json.org/json-en.html) [Strongly Typed Delegates](https://docs.microsoft.com/en-us/dotnet/csharp/delegates-strongly-typed)*

*1.06.54We've a red squiggly line under `GetFromAsync` so to get rid of the error flgged by the c-sharp compiler we must bring in the `system.net.http.json namespace`. This is where the `GetFromJsonAsyc extension method` resides. The `GetItems action method` that we're calling in our web api component will return a collection of objects of type `ProductDto in Json format`. The Json data will automatically be translated into an IEnumerable collection of objects of type productdto for us. So Our products variable here will reference the returned result which will be an IEnumerable Collection Of objects of type ProductDto. So we could add additional codes to handle the htttp response returned from the web api component. We'll look at writing code for this. When we look at `exception handling` in more details in a later project. For now i just want to go through the basics of returning data from the web api component & displaying the data to the user from code created within the blazor web assembly component. 1.08.09So Now we're going to create our razor component where we'll create the code to display the data to the user i.e. the data return from the service functionality We've just created. Razor components are fundamental to blazor simply put blazor apps are are built using razor components. So within the pages folder let's create a razor component named Products.razor. Note we're able to create our code to call our service functionality directly within our razor file within the code section here. In the interest of creating cleaner code we're going to abstract the code for consuming our service functionality within a base class. Our razor component then inherit from the appropraite base class. So let's create a `CSaharp class` named `ProductsBase`. So in order for our base class to be inherited from our Razor component our base class must inherit from a class named ComponentBase which resides withih the `Microsoft.AspNetCore.Components namespace`. `1.09.44`So let's got our razor file. We want our Products.razor component to be invoked when our application is first loaded. so we can ensure that this happens by declaring information about our razor components root at the top of this page like this. Not that when a razor components with at page directive is compiled the generated component class is proivided a root attribute specifying the component's root template. Here we're just providing a forward slash this means that when the URL contains only the `base URL` for our blazor component that our `products.razor` component will be invoked & now we can write code within our razor files that declares that our `products.razor` components inherits from the `ProductBase Class` like this. So let's go back to our `ProductBase class`. Let's create a property to facilitate dependency injection of an object of type IProductService into our Products razor comnponent. So Let's define a public property of type IProductService named ProductService. So to indiacte to dotNet that we want an object of type IProductService injected into this property we need to decorate the appropriate property with the inject attribute like this & of course we mustn't forget to register our productService class for dependency injection. So to do this let's open the program.cs class & implement the relavent dependency injection configuration code like this. [Microsoft.AspNetCore.Components Namespace](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.components?view=aspnetcore-6.0)*

*`1.11.43`Great. Let's create a public property to expose an `IEnumerable` collection of objects of type `ProductDto`. This collection will be accessible to the relavent razor code that we'll implement in a bit to output the pruduct data. So now we want our code that retrieves our product data from the server our web api component to run when the product's razor component is first invoked. We can do this by `overriding` a `function` named `OnInitializedAsync`. So to override a method we can type override press the spacebar & then select the method that we wish to override. We want to override a method named `OnInitializedAsync`. So let's select the appropriate item here.The `OnInitializedAsync` method is associated with a `Blazor lifecycle event`. Let's read a little bit about lifecycle events on this microsoft docs webpage. The razor component processes razor component life cycle events in a set of synchronous & asyschronous life cycle methods can be overridden to perfrom additional operations in components during components `initialization and rendering`. `1.13.08`If the component is rendering for the first time on a request craete the component instance. Perform property injection, run set parameters async call on initialized async if an incomplete task is returned the task is awaited and then the component is rendered. So within the uninitialized async method let's implement the code for retrieving our product data from our web api component like this. We're using the object of type IProductService that will be injected into this class at runtime to return the relavent products data to our product component. Let's implement code for outputting the product data. So if the product property is `null` i.e. has not yet been retrieved from server. We can output a loading indicator to the user so while the data is being retrieved this loading indicator will remain on the user's screen else when the relavent product data has `populated` the products property. We want code to execute that outputs the product's data to the user in an aesthetically pleasing style. 1.15.29Let's bring in the namespace of our ProductDto class, We can include this using directive in the underscore in the `_Imports.razor` file and this means that this using directive will apply to the other razor files as well. Let's write a linq Query here that sequentially takes four items at a time from the collection of ProductDto objects. Images relavent to each of the products has been uploaded to github. Please feel free to download this images. Each image maps to a row of data in the products table in our database. We seeded our database with the relevant data in the first part of this project. Let's then implement code to appropriately output the product data. Bootstrap 5 is being used to output each item of products data as a `bootstrap card`. Later we're going to abstract this code further to clean up the code a bit. The final code for this functionality is available on github. The appropriate link can be found below in the description. For now i just want to write code to display our product data appropriately to the user. [function](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/methods) [OnInitializedAsync Method](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.components.componentbase.oninitializedasync?view=aspnetcore-6.0) [ASP.NET Core Razor component lifecycle](https://docs.microsoft.com/en-us/aspnet/core/blazor/components/lifecycle?view=aspnetcore-6.0) [Task.RunSynchronously Method](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.runsynchronously?view=net-6.0) [ASP.NET Core Razor component rendering](https://docs.microsoft.com/en-us/aspnet/core/blazor/components/rendering?view=aspnetcore-6.0) [How to initialize objects by using an object initializer (C# Programming Guide)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/how-to-initialize-objects-by-using-an-object-initializer) [Object and Collection Initializers (C# Programming Guide)
](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/object-and-collection-initializers) [null (C# Reference)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/null) [How to populate object collections from multiple sources (LINQ) (C#)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/how-to-populate-object-collections-from-multiple-sources-linq) [ASP.NET Core Razor components](https://docs.microsoft.com/en-us/aspnet/core/blazor/components/?view=aspnetcore-6.0) [Cards ¬∑ Bootstrap](https://getbootstrap.com/docs/4.0/components/card/)*

*1.18.11It was pointed out in the comment section that my spelling of the word furniture is incorect both in the `ShopOnlineDbContext class` and the sidebar in the prototype` shopping cart application` that i created in preparation of this project. I dont't know why i spelled furniture with an a like this for nature. But clearly that's what i did. That consequence is that after you ran the `migration` to `create and seed your database`. The word furniture may be incorrectly spelt in your product database table & your products category database table. Of course you may have spotted this and fixed this before creating and running the relavent migration if not the good news is that is easy to fix. I thought that fixing this issue gives us a great oppurtinity to see how easy it to fix issues like this during the development face of our application using `ef7 migrations`. We can fix this relevant data simply by correcting the spelling issue within the on model creating method in the `ShopOnlineDbContext` Class. We can then generate a migration that will contain the code that can be used to update the database with the relevent fix. 1.19.31So of you run your migration where the word furniture was spelt incorrectly within the `OnModelCareting method` of your `ShopOnlineDbContext class`. Please follow along with these steps to fix the issue within your database. Please note that the appropriate spelling fixes regarding all instances of the word furniture have been uploaded to the relavent github repository. Ofcourse the link to the relavent repository is included below in the description. So Let's open the ShopOnlineDbcontext class. That can be found in the data folder within the ShopOnline.Api Project. 1.20.08Let's go the OmModelCreating method. So let's press Ctrl+f so that we can perform a find & replace on the incorrectly spelt word furniture. Okay clearly i can't even make the excuse that this was a typo look at how consistent i've been in spelling the word furniture wrong. Right let's replace the incorrect spelling of the word furniture with the correct spelling of the word furniture. So eight occurrences and here are some instances where our find & replace did not fix the spelling. Because our search was matching the whole word. So let's amend the relavent image file name references for these particular instances. Of course make sure that furniture is spelled correctly for the relavent furniture folder & the relavent image files on your local machines. I did correct the spelling issue before i uploaded the image files to github. So your file system should contain the correct spelling from when you downloaded the relavent files from github. We can now invoke the package manager console window from within visual studio & create a migration to fix our issue. So let's create a new mighration by typing in the add dash migration command. 1.21.43And you can see that the appropriate code to fix the relevent data in our database is generated for us in a new migration class. If we're happy with the relevent migration code. we can run the update database command to fix the relevent data in our databases. So let's do that. great, So we're now ready to run our code in order to run both web api component and the blazor component simultanously through visual studio. We can configure the ShopOnline.Api project & ShopOnlin.Web project to startUp Like same time like this. But we want the ShopOnline.Api project to start a little bit earlier. Before we run our code let's delete the Index.razor file from within our pages directory. This razor component is also configured with the same route as we've configured for our products razor component & we're not going to use the index.razor component that was generated by default in our application. So now when we first run this code we're actually going to get an exception. I'll expalin why in a bit and then we'll take steps to resolve the issue. Let's press the play button to run the code. Youn can see here that we've an `exception` coming from our blazor component. 1.24.10If we press f12 while our chrome browsers are active we can examine the relavent error message here. the exception is caused as a result of `CORS or Cross origin resource sharing`. `Cross-Origin Resource Sharing CORS` is a `http header based mechanism` that allows a server to indiacte any `origins domains` `scheme or port` other than its own from which a browser should permit loading resources. Basically this error occurs because our blazor component has a different `base url` to our web api component. As a result of this a `security` barrier prevents us from being able to access the relevant resources returned from our web api component. 1.25.02Let's copy the `base url` from our blazor component to our clipboards. you'll see why we're doing this in a bit. We're able to `configure a policy` within our web to explicitly allow for blazor component to access relevent resources. So to do this let's open the program.cs file within our ShopOnline.Api Project & include the relevant CORS policy code like this. So where you see the URLs int his block of code. Please paste the BAseURL for your blazor component for the relevent url arguments. Note that we can configure both the http version of our url and the https version of our url in this CORS policy code & please ensure that you don't include a forward slash charecter at the end of these url arguments. Great, Let's run the code again. Excellent we now have our product data appropriately displayed to us, When we first load our application. So all is working fine, but we look at our product.razor file. We can see that we've written quite a lot of code here. We can make this code that outputs a row of prtoducts reusable by abstracting this into its own component. Its own razor component. By abstracting this code into ots own razor component. We're not allowing for the relevant code to be reusable by other razor parent components. We're also creating cleaner code. So to do this we can create a child razor component to house the code that outputs the relevent product data. so let's create a razor component named DisplayProducts.razor. 1.28.18Let's create a CSharp class named displayProductBase Which will of course be the base class for our DisplayProducts.razor component. Let's make our DispalyProductsBase class inherit from the component base class. We want a parent razor component to be able to pass an IEnumerable collection of object of type ProductDto to our DispalyProducts.razor child component. We can achieve this by creating parameter property within our DispalyProductsBase class like this. It is important to note that a parameter property is decorated with the parameter attribute. Let's go to the DispalyProducts.razor file & implement code to inherit from our displaybase class. Then we can go to our Products.razor file & cout the relavent code & paste it into our DispalyProducts.razor file like this. [Migrations Overview](https://docs.microsoft.com/en-us/ef/core/managing-schemas/migrations/?tabs=dotnet-core-cli) [Data Seeding](https://docs.microsoft.com/en-us/ef/core/modeling/data-seeding) [Handle errors in ASP.NET Core Blazor apps](https://docs.microsoft.com/en-us/aspnet/core/blazor/fundamentals/handle-errors?view=aspnetcore-6.0) [Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) [HTTP headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers) [Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin) [ASP.NET Core security topics](https://docs.microsoft.com/en-us/aspnet/core/security/?view=aspnetcore-6.0) [https://docs.microsoft.com/en-us/aspnet/core/security/?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies?view=aspnetcore-6.0) [https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/security/authorization/iauthorizationpolicyprovider?view=aspnetcore-6.0) [Enable Cross-Origin Requests (CORS) in ASP.NET Core](https://docs.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-6.0) [Property Parameters](https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/property-parameters?view=powershell-7.2) [Attributes (C#)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/attributes/)*

*1.32.28We can also include a category heading for each group of products & of course each row containing the grouped products must reside within the loop like this. Let's also include a dividing line between each product group. great, We can clean up this code even further by abstracting therelevent link code within the appropriate base class like this. Great, and let's say that we only wish to dispaly four items for each product category. We can achive this by using LINQS take extension method like this. Excellent, the last thing i'd like to do is add basic animation effects to each of the bootstrap cards we're using to represent our products. So to add a css class that only applies to a particuar razor component we can add a style sheet with a name that adheres to a specific naming convention. So let's add a css style sheet to the pages directory & let's name the stylesheet DispalyProduct.razor.css. This naming convention ensures that the styled contains within this file will only apply to the DispalyProducts.razor component. Which is the component that outputs the bootstrap cards that represent our products. This project is not about css so i've pre-prepared the relavent css code. So i'm just going to paste the relevent code onto the DispalyProducts.css file here. This code is of course accessible from within the relevant github repository. Let's run the code & you can see that  when we hover our mouse pointers over a card the relevant image scales and a box shadow appears. These basic animation effects have been included to enhance the user's UX. Excellent. [C# if statements and loops - conditional logic tutorial](https://docs.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/tutorials/branches-and-loops-local) [scale()
](https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/scale) [:hover](https://developer.mozilla.org/en-US/docs/Web/CSS/:hover) [box-shadow
](https://developer.mozilla.org/en-US/docs/Web/CSS/box-shadow)*

*1:40:00*

### üèÜ  Learn (Research. Study)

*C#11 [C# 11 Preview documentation](https://docs.microsoft.com/en-us/dotnet/csharp/)  [using (C# Reference)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using) [C# Keywords](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/) [C# programming guide](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/) [C# reference](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/) [Objects - create instances of types](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/objects)[Methods](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/methods) [Access Modifiers (C# Programming Guide)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers) [Integral numeric types (C# reference)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/integral-numeric-types) [Properties (C# Programming Guide)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/properties) [Strings and string literals](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/strings/) [The C# type system](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/)*

*ef7  [Tutorial: Get Started with Entity Framework 6 Code First using MVC 5](https://docs.microsoft.com/en-us/aspnet/mvc/overview/getting-started/getting-started-with-ef-using-mvc/creating-an-entity-framework-data-model-for-an-asp-net-mvc-application)*  *Blazor [awesome-blazor, Resources for Blazor, a .NET web framework using C#/Razor and HTML that runs in the browser with WebAssembly.](https://github.com/AdrienTorris/awesome-blazor) [Blazor University](https://blazor-university.com/) [Blazor For Beginners By Jef Fritz](https://www.youtube.com/playlist?list=PLdo4fOcmZ0oUJCA3DCzKT79Oe3kdKEceX)  [WebAssembly 1.0 ](https://webassembly.org/) * *ASP.NET CORE  [ ASP.NET MVC 5.2.3 Beta](https://docs.microsoft.com/en-us/aspnet/mvc/)  [ASP.NET Identity](https://docs.microsoft.com/en-us/aspnet/identity/)[ASP.NET Core Middleware](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-6.0)* *.Net   [.NET CLI overview](https://docs.microsoft.com/en-us/dotnet/core/tools/)* *Web Api  [WEB Api](https://www.geeksforgeeks.org/what-is-web-api-and-why-we-use-it/) [Open Api](https://www.openapis.org/)* * http3 [Server-side website programming](https://developer.mozilla.org/en-US/docs/Learn/Server-side) [HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP)*

###  üì¶ Tips & Tricks
---
```
Problem: Add-Migration InitialCreate Not Working `Could not load assembly 'ShopOnline.Web'. Ensure it is referenced by the startup project 'ShopOnline.Api'.`
Solution: `https://www.thecodebuzz.com/build-failed-efcore-scaffold-dbcontext-command-pmc/`
```
```
Problem: Add-Migration InitialCreate
Build started...
Build failed.
Solution: Open ShopOnlineDbContext.cs file Then Check the code & find the error. Two error found at UserName. Open User.cs Entities. Correct the int to string type.
```
```
[Q]  Why We Use Migrations?
[A] Migration Allow us to evolve our database without loosing data or database object.
```
