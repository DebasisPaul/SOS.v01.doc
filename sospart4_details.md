*Start Part-4 1:40:04 30 Minutes Read*

*1:40:00 So this is the fourth part of the series of project dedicated to building a shoping cart application on dotnet 7 prev 5. using blazor web assembly & web api. We're now created our first workflow which involved retrieving product data form the database & displaying the data to the user in an aesthetically pleasing style. We have built our database using Ef7. We've implemented code using the `Repository Design Pattern` within a web api component in order to return products data from our database to a calling client. In the last part of this series part-3 we implemented code for our blazor web assembly component to call an appropriate action method within our web api component using a `http get request` in order to retrieve product data from the server and display the data to the user in an aesthetically pleasing style. We want to create functionality to retrieve data for a specific product from the server and display the details of that product to the user. So when the user clicks on a particular product only the details for that specific product are displayed to the user. The user can then decide whether or not to add the product to the user's shopping cart. A button will be provided within the razor component responsible for displaying the relavent products details whereby a user can click this button and add the relavent product to the users shopping cart. we'll implement the code for the add to cart button in the next Part.*

*1:41:42so let's go to the web api component let's open the product repository class and go to the get item method you can see that currently we have a default implementation for this method which was created when we generated the code staffs through visual studio of the iproductrepository interface that we are implementing in the product repository class. so as the name implies the get item method returns data regarding a single item so we can use the find async method to retrieve the data pertaining to the product that matches the id value passed into the get item method through code like this the next step is to expose the functionality to a calling client by implementing code that gets executed in reaction to an appropriate http get request. so we want the get item functionality to execute when a calling client makes an appropriate http get request for product data that can be identified in the system with the id value passed to our web api component from the calling client we can implement code that creates an appropriate http response through creating an action method within our ProductController controller class.*

*1:43:13so let's create a method within the product controller class to return data for a particular product to speed things up let's duplicate the get items action method that we created in the second part of this series and change the code appropriately so as to implement the functionality for the get item action method we only want to return data for one object of type product dto rather than an i enumerable collection of objects of type product dto to the calling client so let's change the return type appropriately let's include a parameter named id which is of type integer this id parameter denotes the id value of the product data for which the client wishes to have returned from our web api component within the http get attribute let's include the appropriate root template information our get item action method contains a parameter of type integer named id so for the get item action method it is appropriate to pass in an argument of type string to its corresponding http get attribute that denotes the appropriate root template for this action method*

*1:44:32so let's use the product repository object passed into our controller class via dependency injection to call the getitem method that we have just implemented within the product repository class so if the returned value is null this means that the resource does not exist so let's pass a response to the calling client that includes a bad request status code we can do this in code by returning the result returned from the bad request method like this so let's say we also want to include the name of the category under which the relevant product falls in the returned object as we know we only have the id of the category under which the returned product falls within the product entity we don't have the facility to store any other information pertaining to the products category within the product entity so we need to write code to get the category information from the product category entity we can then include the product information and the category information in an object of type product dto and return the relevant object of type product dto to the calling client*

*[Dependency injection in .NET](https://docs.microsoft.com/en-us/dotnet/core/extensions/dependency-injection)*

*1:45:47so let's implement code for the get category method within the product repository class to retrieve data for our specific category based on the category id passed into this method let's then write code within our get item action method to appropriately call the get category method on the object of type i product repository like this the next step is to write the code that merges the data pertaining to a specific product with the data pertaining to the relevant products category into one object of type product dto in order to write the code for this in a clean way we can create a convert to dto extension method overload within our dto conversions class so the convert to dto extension method currently within our dto conversions class converts a collection of products and a collection of product categories appropriately into a collection of objects of type product dto and returns the collection of objects of type product dto to the calling code we want our new convert to dto extension method overload to convert one object of type product and related object of type product category into one object of type product dto and return the subject of type product dto to the calling code this is basically so that we can include the relevant product data and the category name within one object our product dto type facilitates this so we can write code to perform the relevant conversion like this*

*1:48:30we can now go to our get item action method and call the convert to dto extension method which is now available on this object of type product to return the appropriate object of type product dto to our action method we can then write code to return a http status code of 200 okay along with the relevant object of type product dto to the calling client by appropriately returning the result of the ok method and passing in the appropriate object of type product dto to the ok method if an exception occurs for some reason during the execution of the get item action method we have code here that will return a http status code of 500 denoting an internal server error to the calling client along with an appropriate error message great so let's write code within the blazor component to make an appropriate http call to the server side code that we have just implemented so let's open our i product service interface let's include a method definition for a method where we will implement the code to call the get item action method on the server we want this getitem method to run asynchronously so we are returning a task object the getitem method is returning a value so we must pass the return type as a type argument to the generic task type here this method contains a parameter of type integer and is named id this id parameter denotes the id value that is used to identify a specific product so let's implement the get item method*

*1:50:23in the product service class let's generate a try catch block in the previous part of this series part 3 we implemented code for the get items method that uses the http client objects get from json async method to call the relevant server side action method this method calls the relevant action method but also handles translating the returned json data into the appropriate objects type i'm going to use the get async method to call the relevant action method in our get item method this method doesn't convert the returned json data to the appropriate object type we need to write code for this separately we'll do that in a bit the get async method returns a http response object so we can use the returned object to first as certain as to whether our http request to the server was successful so this code checks that the relevant status code falls within the success range so if the call is successful we want code to execute that checks if our http request has returned a response with content if there is no content returned from the server we want code executed that returns the default value associated with the product dto type like this so the c sharp default value for a user defines type which is a reference type will be null so this is just the way i'm choosing to handle the scenario where the call to the server is successful but for some reason no data is returned from the server*

*so when the call is successful and content is returned from the server we want code to execute that translates the json data returned from the server into an object of the appropriate type else if the call to the server is not successful we want code to execute that handles the exception so here we are just going to throw the exception at this point and we can pass the message sent back from the server as an argument to the exception object like this within the catch block we could implement codes to log the exception or handle the exception in an appropriate manner that we choose let's implement appropriate code within the get items method to also include exception handling functionality so let's create a razor component within the pages folder let's name this component productdetails.razor so this is the component where we'll implement the code to display details regarding a specific product let's create the base class for our product details component and let's name this component product details base let's implement the code for our product details base class we want the id parameter that denotes the identifier for a specific product to be passed into the component so let's create a parameter named id that is of type integer we need to decorate this property with the parameter attribute*

*1:55:52we also need to ensure that our base class inherits from the component base class so we want an object of type i product service to be injected into our product details component so we can do this by including a property within our base class of type iproduct service and decorate the relevant property with the inject attribute let's include a property of type product dto within our base class and let's name this property product let's include a string property to store an exception message so we want code to execute when our blazer component is first invoked so we can ensure that this happens by writing the relevant code within a method that overrides the uninitialized async method to generate the appropriate uninitialized async method let's type in override followed by pressing the space bar and then let's select the appropriate method from the list presented to us let's generate a try catch block within the try catch block let's appropriately call the get item method on the injected object of type i product service the returned value is assigned to our product property which we can then access from our product details.razer file if an exception occurs we want the exception message to be assigned to the error message property let's implement code to output details regarding the relevant product so let's ensure that we include the appropriate root template at the top of the file we can use the page directive for this purpose and notice how we are including the id parameter here this is because an appropriate id parameter must be passed to this razor component when this razor component is invoked let's write the code logic so while the product property is null and the error message property is null*

*1:58:53we want a loading indicator to be displayed to the user else if an error occurs in which case the error message property will not be null we want the error message to be displayed please note that for the sake of this example we are writing functionality to display the error message returned from the server to the screen in a complete application it would be more appropriate to output a user-friendly non-technical error message to the user and log the actual error message returned from the server else we want to output the details of the relevant product in an aesthetically pleasing style to the user and of course bootstrap 5 classes are being used here to output the data in an aesthetically pleasing style great then let's go to the display products.razer file and include the appropriate value for the href attribute within the anchor tag that wraps the cards that represent the products sold in our online store so we want this link to invoke the product details razer component we need to include the appropriate id value denoting the identifier for a specific product within our href attribute value here let's run the code great let's abstract the code that outputs an exception to the user in its own razor component so that we can reuse this component from within multiple parent razor components this is also a cleaner way of implementing the code that displays an error message to the user let's write code to force an exception to occur so we know that a product with an id of 1000 does not exist in the system so in this case the server will send back a response code indicating that a bad request has been made*

*2:02:43let's run the code great lastly it would be better in terms of a user's ux if an appropriate animated loading indicator was displayed to the user while the user is waiting for data to be displayed so if we navigate to this site here we can copy the relevant html and css code for an animated loading indicator of our choice these loading indicators here can be used within our application free of charge so let's select this one let's copy the html and the css code for the loading indicator of our choice and integrate the code within our application the cleanest way to integrate this code into our applications in my opinion is to abstract the loading indicator code within a razor component as discussed in the previous part of this series part 3 we are able to create a css file that only applies to its corresponding razer component by naming the relevant css file in a way that adheres to a specific naming convention so if the name of the razer component is display spinner we can create a css file that will only apply to this razor component by naming the relevant css file display spinner.razer.css so we can now reuse the spinner functionality for multiple parent components i look forward to presenting the next video in this series where we'll create the functionality for adding products to a shopping cart* 

*End of Part-4 2:05:54*
