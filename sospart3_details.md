*Part-3*

*57.44So this is the third part of this project. Where we're building a `shopping cart application` using `blazor WebAssembly` & `Web Api`. We're building our application on .Net7 prev5. Which at the time I writing this project is the latest version of dotnet. We're now at stage where we're build our database using `ef7` `code first migrations`. & i've started implementing code for the `first workflow` which simply involved `retrieving product data` from our database & displaying this product data to the user. In part 2, the previous part of the project, we implemented the code that retrives the relavent product data from our database & returns the data to the `calling client`. This code was implemented in an `action method` within a `controller class` named `ProductController`. This class was created with in our `ShopOnline.Api` project which contains the code for our web api components.*

*58.52In this part we want to start developing the code for our `client side blazor component`. So in this part we'll implement code within our blazor component to `call the action method` that we developed in the previous part of this project and display the return data to the user. So let's get started. The first thing we need to do is copy the url to our clipboard. Which is the url of our web api component. When we run the `ShopOnline.Api` project through Visual Studio. We're doing this so that we can appropriately configure our blazor component to point the appropriate local web api url. So that we can easily test our application through visual studio during the development phase of our `shopping cart application`. One way we can access the relevant url is to simply run our web api project. So let's copy this part of the url which we can refer to as the `base url or base address` to our clipboards. Then let's open the `Program.cs` class within our `ShopOnline.Web` component.* 

*1.00.05So here is a block of code that was automatically included within our `ShopOnline.Web` Component. Whereby the `http client object` is configured for `dependency injection`. This means that we will automatically have access to a `http client object` from appropritely written classes within our `Blazor component`. We will be using the `http client object` to call relevent `action methods` within our `web api component`. So in order for our `http client component` to point to the `web api component` on our local machines. We need to replace the `argument` that is currently being passed to the `Uri Constructor` here. With the `base URL` that we've just copied to our clipboard. So let's appropriately paste the `base url` copied to our clipboards here. Great. So we're going to wrap the `functionality` that handles `calls` to our web api component within `services`. These `services` are simply `CSharp classes` that wrap the `functionality` for handling `interections` with our `web api Component`.* 

*1.01.25 So the first things to do is create a folder named `Services`. Then within the services folder let's create a folder named `Contracts`. Let's create an interface named `IPrpductService` within the Contracts folder. So We'll build up the `methods` for the product service class over time when appropriate during the development of our application. We're just going to implement code for one method in this video. So let's create a method defination for our method in the `IProductService` file. We want our method to run `Asynchronously` so our method will return a task `object`. I this case we're going to write code to return a `generic task` object. Because this method must return a value to the calling code. The type of value that we want to return to calling code is an IEnumerable collection of object of type `ProductDto`. Let's name this method `GetItems`. In a bit we'll implement code for this method to retrieve relevent product data from the appropriate action method that resides within our web api component. We've a red sqiggly line under `ProductDto`. The `ProductDto` type is defined within the `ShopOnline.Models` Project. So Let's create a `project reference` to the ShopOnline.Models Project. Let's then bring in the namespace for the ProductDto type. 1.03.29Great. Okay. So let's create the code to implemnt our IProductService Interface. So let's craete a class named ProductService directly within the Services folder. Let's carete a `Constructor`. So we want to tell dot net as it were that we want a http client objects. to be `injected` into our ProductService class. So to do this we simply define a parameter of type http client within our Constructor defifition. Then let's generate a `read-only member variable` to reference the object of type `http client` that will be injected into this class at `runtime`. The next things to do is to implement the `IProductService Interface`. So let's write the code for this. Let's generate the code stuff for the method that we've defined IProductService Interface. Let's write the code for the `GetItems` method. Let's first generate a `try-catch block`. Within the `try block` let's write code to call the `GetItems action method` that resides with in the `ProductController` of our web api component. 1.05.17 We're Using the `generic GetFromJsonAsync method` to call the apporipaiate action method withiin our Web Api component. We're passing in a type argument which is an IEnumerable collection of type `ProductDto` to the `GetJsonAsync Generic method`. We're doing this because we want our `GetFromJsonAsync method` to return an `IEnumerable collection of type` `ProductDto`. So this method will translate the data which will be in `Json format` returned from the web api component into an `object of type IEnumarable`, Which is `strongly typed` with the type `ProductDto`. Notice that we're passing in `texture` which denotes where the collection of resources that we want to retrieve from our web api component can be found. The web api component will know as it were to invoke the `GetItems action method` within the `ProductController class` of our web api component based on this information passed as an argument To the `GetFromJsonAsync method`.*

*1.06.54We've a red squiggly line under `GetFromAsync` so to get rid of the error flgged by the c-sharp compiler we must bring in the `system.net.http.json namespace`. This is where the `GetFromJsonAsyc extension method` resides. The `GetItems action method` that we're calling in our web api component will return a collection of objects of type `ProductDto in Json format`. The Json data will automatically be translated into an IEnumerable collection of objects of type productdto for us. So Our products variable here will reference the returned result which will be an IEnumerable Collection Of objects of type ProductDto. So we could add additional codes to handle the htttp response returned from the web api component. We'll look at writing code for this. When we look at `exception handling` in more details in a later project. For now i just want to go through the basics of returning data from the web api component & displaying the data to the user from code created within the blazor web assembly component. 1.08.09So Now we're going to create our razor component where we'll create the code to display the data to the user i.e. the data return from the service functionality We've just created. Razor components are fundamental to blazor simply put blazor apps are are built using razor components. So within the pages folder let's create a razor component named Products.razor. Note we're able to create our code to call our service functionality directly within our razor file within the code section here. In the interest of creating cleaner code we're going to abstract the code for consuming our service functionality within a base class. Our razor component then inherit from the appropraite base class. So let's create a `CSaharp class` named `ProductsBase`. So in order for our base class to be inherited from our Razor component our base class must inherit from a class named ComponentBase which resides withih the `Microsoft.AspNetCore.Components namespace`. `1.09.44`So let's got our razor file. We want our Products.razor component to be invoked when our application is first loaded. so we can ensure that this happens by declaring information about our razor components root at the top of this page like this. Not that when a razor components with at page directive is compiled the generated component class is proivided a root attribute specifying the component's root template. Here we're just providing a forward slash this means that when the URL contains only the `base URL` for our blazor component that our `products.razor` component will be invoked & now we can write code within our razor files that declares that our `products.razor` components inherits from the `ProductBase Class` like this. So let's go back to our `ProductBase class`. Let's create a property to facilitate dependency injection of an object of type IProductService into our Products razor comnponent. So Let's define a public property of type IProductService named ProductService. So to indiacte to dotNet that we want an object of type IProductService injected into this property we need to decorate the appropriate property with the inject attribute like this & of course we mustn't forget to register our productService class for dependency injection. So to do this let's open the program.cs class & implement the relavent dependency injection configuration code like this. [Microsoft.AspNetCore.Components Namespace](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.components?view=aspnetcore-6.0)*

*`1.11.43`Great. Let's create a public property to expose an `IEnumerable` collection of objects of type `ProductDto`. This collection will be accessible to the relavent razor code that we'll implement in a bit to output the pruduct data. So now we want our code that retrieves our product data from the server our web api component to run when the product's razor component is first invoked. We can do this by `overriding` a `function` named `OnInitializedAsync`. So to override a method we can type override press the spacebar & then select the method that we wish to override. We want to override a method named `OnInitializedAsync`. So let's select the appropriate item here.The `OnInitializedAsync` method is associated with a `Blazor lifecycle event`. Let's read a little bit about lifecycle events on this microsoft docs webpage. The razor component processes razor component life cycle events in a set of synchronous & asyschronous life cycle methods can be overridden to perfrom additional operations in components during components `initialization and rendering`. `1.13.08`If the component is rendering for the first time on a request craete the component instance. Perform property injection, run set parameters async call on initialized async if an incomplete task is returned the task is awaited and then the component is rendered. So within the uninitialized async method let's implement the code for retrieving our product data from our web api component like this. We're using the object of type IProductService that will be injected into this class at runtime to return the relavent products data to our product component. Let's implement code for outputting the product data. So if the product property is `null` i.e. has not yet been retrieved from server. We can output a loading indicator to the user so while the data is being retrieved this loading indicator will remain on the user's screen else when the relavent product data has `populated` the products property. We want code to execute that outputs the product's data to the user in an aesthetically pleasing style. 1.15.29Let's bring in the namespace of our ProductDto class, We can include this using directive in the underscore in the `_Imports.razor` file and this means that this using directive will apply to the other razor files as well. Let's write a linq Query here that sequentially takes four items at a time from the collection of ProductDto objects. Images relavent to each of the products has been uploaded to github. Please feel free to download this images. Each image maps to a row of data in the products table in our database. We seeded our database with the relevant data in the first part of this project. Let's then implement code to appropriately output the product data. Bootstrap 5 is being used to output each item of products data as a `bootstrap card`. Later we're going to abstract this code further to clean up the code a bit. The final code for this functionality is available on github. The appropriate link can be found below in the description. For now i just want to write code to display our product data appropriately to the user.*

*1.18.11It was pointed out in the comment section that my spelling of the word furniture is incorect both in the `ShopOnlineDbContext class` and the sidebar in the prototype` shopping cart application` that i created in preparation of this project. I dont't know why i spelled furniture with an a like this for nature. But clearly that's what i did. That consequence is that after you ran the `migration` to `create and seed your database`. The word furniture may be incorrectly spelt in your product database table & your products category database table. Of course you may have spotted this and fixed this before creating and running the relavent migration if not the good news is that is easy to fix. I thought that fixing this issue gives us a great oppurtinity to see how easy it to fix issues like this during the development face of our application using `ef7 migrations`. We can fix this relevant data simply by correcting the spelling issue within the on model creating method in the `ShopOnlineDbContext` Class. We can then generate a migration that will contain the code that can be used to update the database with the relevent fix. 1.19.31So of you run your migration where the word furniture was spelt incorrectly within the `OnModelCareting method` of your `ShopOnlineDbContext class`. Please follow along with these steps to fix the issue within your database. Please note that the appropriate spelling fixes regarding all instances of the word furniture have been uploaded to the relavent github repository. Ofcourse the link to the relavent repository is included below in the description. So Let's open the ShopOnlineDbcontext class. That can be found in the data folder within the ShopOnline.Api Project. 1.20.08Let's go the OmModelCreating method. So let's press Ctrl+f so that we can perform a find & replace on the incorrectly spelt word furniture. Okay clearly i can't even make the excuse that this was a typo look at how consistent i've been in spelling the word furniture wrong. Right let's replace the incorrect spelling of the word furniture with the correct spelling of the word furniture. So eight occurrences and here are some instances where our find & replace did not fix the spelling. Because our search was matching the whole word. So let's amend the relavent image file name references for these particular instances. Of course make sure that furniture is spelled correctly for the relavent furniture folder & the relavent image files on your local machines. I did correct the spelling issue before i uploaded the image files to github. So your file system should contain the correct spelling from when you downloaded the relavent files from github. We can now invoke the package manager console window from within visual studio & create a migration to fix our issue. So let's create a new mighration by typing in the add dash migration command. 1.21.43And you can see that the appropriate code to fix the relevent data in our database is generated for us in a new migration class. If we're happy with the relevent migration code. we can run the update database command to fix the relevent data in our databases. So let's do that. great, So we're now ready to run our code in order to run both web api component and the blazor component simultanously through visual studio. We can configure the ShopOnline.Api project & ShopOnlin.Web project to startUp Like same time like this. But we want the ShopOnline.Api project to start a little bit earlier. Before we run our code let's delete the Index.razor file from within our pages directory. This razor component is also configured with the same route as we've configured for our products razor component & we're not going to use the index.razor component that was generated by default in our application. So now when we first run this code we're actually going to get an exception. I'll expalin why in a bit and then we'll take steps to resolve the issue. Let's press the play button to run the code. Youn can see here that we've an `exception` coming from our blazor component. 1.24.10If we press f12 while our chrome browsers are active we can examine the relavent error message here. the exception is caused as a result of `CORS or Cross origin resource sharing`. `Cross-Origin Resource Sharing CORS` is a `http header based mechanism` that allows a server to indiacte any `origins domains` `scheme or port` other than its own from which a browser should permit loading resources. Basically this error occurs because our blazor component has a different `base url` to our web api component. As a result of this a `security` barrier prevents us from being able to access the relevant resources returned from our web api component. 1.25.02Let's copy the `base url` from our blazor component to our clipboards. you'll see why we're doing this in a bit. We're able to `configure a policy` within our web to explicitly allow for blazor component to access relevent resources. So to do this let's open the program.cs file within our ShopOnline.Api Project & include the relevant CORS policy code like this. So where you see the URLs int his block of code. Please paste the BAseURL for your blazor component for the relevent url arguments. Note that we can configure both the http version of our url and the https version of our url in this CORS policy code & please ensure that you don't include a forward slash charecter at the end of these url arguments. Great, Let's run the code again. Excellent we now have our product data appropriately displayed to us, When we first load our application. So all is working fine, but we look at our product.razor file. We can see that we've written quite a lot of code here. We can make this code that outputs a row of prtoducts reusable by abstracting this into its own component. Its own razor component. By abstracting this code into ots own razor component. We're not allowing for the relevant code to be reusable by other razor parent components. We're also creating cleaner code. So to do this we can create a child razor component to house the code that outputs the relevent product data. so let's create a razor component named DisplayProducts.razor. 1.28.18Let's create a CSharp class named displayProductBase Which will of course be the base class for our DisplayProducts.razor component. Let's make our DispalyProductsBase class inherit from the component base class. We want a parent razor component to be able to pass an IEnumerable collection of object of type ProductDto to our DispalyProducts.razor child component. We can achieve this by creating parameter property within our DispalyProductsBase class like this. It is important to note that a parameter property is decorated with the parameter attribute. Let's go to the DispalyProducts.razor file & implement code to inherit from our displaybase class. Then we can go to our Products.razor file & cout the relavent code & paste it into our DispalyProducts.razor file like this.*

*1.32.28We can also include a category heading for each group of products & of course each row containing the grouped products must reside within the loop like this. Let's also include a dividing line between each product group. great, We can clean up this code even further by abstracting therelevent link code within the appropriate base class like this. Great, and let's say that we only wish to dispaly four items for each product category. We can achive this by using LINQS take extension method like this. Excellent, the last thing i'd like to do is add basic animation effects to each of the bootstrap cards we're using to represent our products. So to add a css class that only applies to a particuar razor component we can add a style sheet with a name that adheres to a specific naming convention. So let's add a css style sheet to the pages directory & let's name the stylesheet DispalyProduct.razor.css. This naming convention ensures that the styled contains within this file will only apply to the DispalyProducts.razor component. Which is the component that outputs the bootstrap cards that represent our products. This project is not about css so i've pre-prepared the relavent css code. So i'm just going to paste the relevent code onto the DispalyProducts.css file here. This code is of course accessible from within the relevant github repository. Let's run the code & you can see that  when we hover our mouse pointers over a card the relevant image scales and a box shadow appears. These basic animation effects have been included to enhance the user's UX. Excellent.*
