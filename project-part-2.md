*26.05 - 57.45 part-2*

*26.05 `Retrieving Product data from database & Returning data to client blazor component` This is the second part in a series of project dedicated to building a shopping cart application using blazor & Restful web api. In this part we're going to start with the workflow that involved retieving product data from our database & returning the data to the client blazor component. The code for this functionality will be implemented with in the web api component. So in this part we're start to `develop our web api` component. Before we do this let's create the classes that represant the data that will be passed between the web api component & the blazor component. [Diagram](https://lucid.app/lucidchart/4715f825-77f7-4867-bf6d-0b9c9961cf0f/edit?viewport_loc=-10%2C-11%2C1707%2C872%2C0_0&invitationId=inv_02814206-a40a-4c94-9087-ab773e457b69#) Might be thinking but we've already created the classes that represant the data for our application, For Example Product, ProductCategory, Cart, CartItem Ext. Yes we did create this classes that represant our entities in the previous part of this project. This entity classes directly map to the database tables that we generated when we ran the relavent migrations. The function of this classes can be seed as blue prints for the correspondent database tables. When we passed data between the web api component & the blazor component we dont necessarly want to passed the exat data to find by the property in the classes that represant the database entities. For example in this project we're going to create code that returns the product data from the web api component to the blazor component. The product class contains certain product related properties one of which is the CategoryId. A particualr categoryId vlue could for example to note that a particular product falls under the electronics category & could for example be a laptop or for a example the product could for under the furniture category & clould be for example a couse. The categoryId property with in the product entity is a foreign key from the product category entity. From a human respective the categoryId property does not have much meaning because of contains a numeric value so it would for example make might sense to display the categoryId to the user we may want to pass the relavent CategoryName in adition to the product information define in the product class. So to facilitate this we can create a new model  that contains all the relavent product data as well as the relavant CategoryName which include in the product category entity & not the product entity. So make sense to create a new model to represant the data that in this case we wish to pass from server to client we need a model that includes all the product information as well as the CategoryName. The type of model i'm referring to is nate as a `DTO` or data transfer object.* 

*29.22`Create Data Transfer Object (DTO) Model` This type of model includes the data that needs to be passed between server & client. So a DTO is an object that defines how the data will be send over the network. Because that represant our entities that we create earlier directly maped to our crrespondent database table. This classes represant the structure of certain tables in our database. We can create `DTOS` data transfer objects that are based on the underline entity classes. but may be differntly shaped based on the data we needs to be passed between client & server. Now we create a standard library project to house of `dtos`.  [Data Transfer Object (DTO)](https://docs.microsoft.com/en-us/aspnet/web-api/overview/data/using-web-api-with-entity-framework/part-5 https://stackoverflow.com/questions/1051182/what-is-a-data-transfer-object-dto)*

*30.24`Create ShopOnline.Models Class Library` for creating the classes that have representingour dtos.*

*34.54`Coding The Logic for first workflow` Starting with the web api component. This workflow simply involved retrieving product data from our database & returning the data to the client blazor application. The blazor application will contain code that displays the relavent product data to the user. So ShopOnlineDbContext class has been registered for dependency injection. We'll see in a bit how we are able to implement code to ensure that an object of type ShopOnlineDbContext is injected into relavent classes.*

*35.31`Repository design Pattern Implementation to abstract data handling layout` Repositories are classes or components that Encapsulate the logic required to access data Sources. We can use repositories to centralized common data access functionality. Which has the benefit of facilitating beta maintainbility, easier Unit Testing, extensibility & Cleaner Code. The best way to Understand the repository pattern is to Implement the relavent code. So let's write the code for Product repository Funtionality. [Implementing the Repository and Unit of Work Patterns in an ASP.NET MVC Application (9 of 10)](https://docs.microsoft.com/en-us/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)
Create Interface that runs asyncronusly, Overturn Generic tasks objects. Our first method is named `get items` & returns an `IEnumerable` Collection of type Product. So a IEnumerable collection is passed as a type argument to the task object as discussed this is so the method that implement this method defination can runs asycronusly.[Asynchronous programming with async and await](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/)[Encapsulation in C#](https://dotnettutorials.net/lesson/encapsulation-csharp/) [How to define abstract properties (C# Programming Guide)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/how-to-define-abstract-properties) [IEnumerable Interface](https://docs.microsoft.com/en-us/dotnet/api/system.collections.ienumerable?view=net-6.0) [interface (C# Reference)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interface) [Task Class](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task?view=net-6.0)* 

*37.48 So we've define the interface that we want to class name ProductRepository to implement. So lets create a class directly with in the repository directory named `ProductRepository` & the first thing we need to do is write the code to implement the `IProductRepository` Interface. 39.08Visual Studio generates the relavent code stuffs for us. So Visual Studio generates default implementations for the rlavent method definations. So in this stage only want to implement the code logic relavent to the web flow that is the focus of this Project. IE returning a collection of product data to the client side calling code in this case our Blazor component. We are going to new to use the `ShopOnlineDnContext Object` to interect with our `ShopOnline Database`. As u will recall earlier we registered the `ShopOnlineDbContext object` for `dependency injection`. This means that we're able to gain access to an object of type `ShopOnlineDbContext` by defining an appropriate parameterized constructor in our pruduct repository class. [new operator (C# reference)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/new-operator) [throw (C# Reference)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/throw) [NotImplementedException Constructors](https://docs.microsoft.com/en-us/dotnet/api/system.notimplementedexception.-ctor?view=net-6.0)*

*40.04 An easy way to automatically generate constructor with in visual studio is type `ctor` & then press the tab key twice. Then in order to indicate dotnet taht we want an object `ShopOnlineDbContext` to be injected into this constructor, all we need to do is define an parameter with in our constructor of type `ShopOnlineDbContext` Lets bring in the appropriate namespace. & We can get visual studio to create an appropriate private readonly member variable to reference our ShopOnlineDbContext object by pressing `Control+Period` & Selecting the appropriate item from the list presented to us by visual studio.  [Objects - create instances of types](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/objects) [Constructors (C# programming guide)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/constructors) [Members (C# Programming Guide)
](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/members)*

*41.02so for the workflow that is the focus of this part we only need to implement code for two of the method defination with in the `iProductRepository` interface. So in this point we're only going to implement code for the `GetItems` method & the `GetCategories` method. So let implements code for `GetItems` method. All we want this method to do is returns all the products from the products table. So let's write the code for this. Note we want our code to run `asyncronusly` so we must include the `await` keyword here. Notice when we've type in the `await` keyword that the `async` keyword automatically appears in the method defination fot the `GetItems` method. If you include the await keyword with in a method. The method in which you include the await keyword must appropriately contain the async keyword. Notes that to include the `ToListasync` extension method get in our code we must bring an the `Microsoft.EntityFrameworkCore` Namespace. That's it. We've written the code to return an `IEnumerable` collection of product data from our database. So lets implement the code to return the `ProductCategories` from our database. We can do this by implementing the appropriate code with our GetCategories method. So now we've now implemented the code for retieving product data from our database. [9 Variables](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/variables) [public (C# Reference)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/public) [private (C# Reference)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/private) [readonly (C# Reference)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/readonly) [Microsoft.EntityFrameworkCore Namespace](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore?view=efcore-6.0)*

*42.56The next step is to write code `To Return the appropriate data to the Calling client` So to do this we need to create an appropriate controller class. Before we create our controller class lets delete `WeatherForecastController.cs` classes that we generated by default when we first created our web api project. This classes obviously not going to be use in our application. So now lets create a class with in our controller directory. Let's ensure that we select the appropriate controller class template. Let's name this class `ProductController`. So the first things to do is to write the code so that an object of type `ProductRepository` is automatically injected into our controller classes constructor via dependency injection. Lets also ensure that we've a read only private field that refereces the object passed in via dependency injection. But we've not yet registered our `ProductRepository` class for dependency injection. So lets write the code for this. Let's open the program.cs file. Let's implement the code to register the ProductRepository class with the dependency injection system. Notice how we use the `AddScoped` method to register our `ProductRepository` class for dependency injection. We could be use the `AddTransient` method or the `AddSingleton` method to register our `ProductRepository` class within the dependency injection system. Then in our case `AddScoped` is the appropriate method for this purpose. Very basicly using `AddTransient` would mean in that a new instance of the relavent object is provided to every class that requires the relavent object to be injected. Using `AddSingleton` Would mean have the same instance of the object injected into the relavent classes for every http request using `Add Scoped` means that the same instance of the object injected into relavent classes with in a particuar http request. Note that in this case new instance of the relavent object would be created for each http request. [Call a Web API From a .NET Client (C#)](https://docs.microsoft.com/en-us/aspnet/web-api/overview/advanced/calling-a-web-api-from-a-net-client) [Controller Class](https://docs.microsoft.com/en-us/dotnet/api/system.web.mvc.controller?view=aspnet-mvc-5.2, https://docs.microsoft.com/en-us/aspnet/mvc/overview/older-versions-1/controllers-and-routing/creating-a-controller-cs) [readonly (C# Reference)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/readonly) [System Namespace](https://docs.microsoft.com/en-us/dotnet/api/system?view=net-6.0) [ServiceCollectionServiceExtensions.AddScoped Method](https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.servicecollectionserviceextensions.addscoped?view=dotnet-plat-ext-6.0) [ServiceCollectionServiceExtensions.AddTransient Method](https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.servicecollectionserviceextensions.addtransient?view=dotnet-plat-ext-6.0) [ServiceCollectionServiceExtensions.AddSingleton Method](https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.servicecollectionserviceextensions.addsingleton?view=dotnet-plat-ext-6.0) [Objects - create instances of types](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/objects)*

*45.52`Lets Create a method defination for action method named GetItems` We want our action method to run asyncronusly. The type that is passed to the generic task object is of the generic action result type. One of the core benefits of returning an action result is that is well as returning requested data from an action method to the client and appropriate response status code can also be return. For example http status code of 200 meets the request has seeded status code of 404 represents that resource could not be found & a http status code 500 represents that an internal server error occured. So we need to pass the type of data that we wish to return to the client as a type arguments to the action results generic type. So we want to return an `iEnumerable` collection of type `ProductDto` to the client.   [Creating an Action (C#)](https://docs.microsoft.com/en-us/aspnet/mvc/overview/older-versions-1/controllers-and-routing/creating-an-action-cs) [Generic Methods (C# Programming Guide)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/generic-methods) [Generic type parameters (C# Programming Guide)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/generic-type-parameters) [Controller action return types in ASP.NET Core web API](https://docs.microsoft.com/en-us/aspnet/core/web-api/action-return-types?view=aspnetcore-6.0) [ActionResult](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.actionresult-1?view=aspnetcore-6.0) [Task](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task-1?view=net-6.0) [Action Results in Web API 2](https://docs.microsoft.com/en-us/aspnet/web-api/overview/getting-started-with-aspnet-web-api/action-results) [The HTTP status code in IIS 7.0 and later versions](https://docs.microsoft.com/en-us/troubleshoot/developer/webapps/iis/www-administration-management/http-status-code) [HTTP response status codes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#server_error_responses)*

*46.56So the first thing we need to do is create a project reference to the `ShopOnline.models` project. Because this is where our `ProductDto` class resides. Then let's bring in the `ShopOnline.Models.Dtos` namespace. Great, let's name our action method `GetItems` each action method in our controller must `map` to a particular `http verb`. For example `Get, Post, Push, Delete` etc. Our `GetItems` action method will be used for getting product data and returning that product data to the client. So the appropriate `http verb` for this action method is `Get`. So to indicate this to `dotNet` we need to decorate our `GetItems` Action method with the `HttpGet` `attribute`. So let's implement the code logic for our `GetItems` action method. Let's first create a `try-catch` block. An easy way to do this in Visual Studio is to type in `try` followed by pressing the tab key twice. So let's write code that calls the `ProductRepository` classes `GetItems` method `asysncronusly` to return an `IEnumerable` collection of type `Product` to our `Action` method. We want to `include` the `CategoryName` associated with each Product in our collection. So let's write code to `return` a collection of `ProductCategory` objects to our `Action method`. We'll write the code that `joins` our collection of `Products` with our collection of `ProductCategories` in a bit. So you may have spotted that the code in this action method is not ideal at the moment. It is not ideal because we are `Retrieving` a collection of `Products` and a collection of `Categories` in two `Separete Queries` to the database. A more performant way for retrieving the Product collection and related category data would be to appropriately use the include `Extension method` within the relavent `LINQ Queries` in the `GetItems` method within the `ProductRepository` class. The use of the `include method` would join the data retrieved from the Products database table with related data retrieved from the `ProductCategories` database table and allow for the Products data and related category data to be returned through one query. I'm going to leave the code as it is for now we'll optimize this code for performance by using the `include extension method` as i've just described toward the end of the course. So if either the product variable is null or the product categories variable is null. Let's return a status code of not found to the calling client code. So in this case our web api will return a http status code of 404 meaning that rlevant data was not found or a relavent resources was not found. So in this case it means that the client request failed and the reason for the failure is that an essential resource could not be found. Else we want to join the collection of ProductCategories with the collection of products. So that we can return a collection of `ProductsDtos` to the calling client code. Which will include the CategoryName. Remember the ProducDto definition contains a CategoryName property. In order to get the CategoryName for each product in the collection. We need to join the collection of type product to the collection of type ProductCategory. We're going to use `LINQ` for this purpose. In order to to avoid creating too many lines of code with in our action method we're going to create an extension method to return a collection type of ProductDto to our action method. So let's create a folder named `Extensions`. let's create class within our `Extensions folder` named `DtoConversions`. Note that in order to create an Extension method we need the class that houses our extesion methods to be static. Let's create our extension method. So the extension method must be a static method and we want to return an IEnumerable collection of objects of type ProductDto to the calling code. Let's name our method convert to dto. The first parameter in an extension method must be the type of an object on which we want to be able to call the conver dto extension method so by convention this parameter definition must also be preceded by this keyword. So on an IEnumerable collection of type product we want to able to call the convert to dto method in order to convert an IEnumerable collection of type product to an IEnumerable collection of type ProductDto. The logic for this method will using a link query join a collection of type product to a collection of type product category and return a collection of type product dto to the calling code. So the second parameter of the convert to dto method is of a type that is an IEnbumerable collection of type product category. Let's write logic for our extension method. So lets write a `lINQ query` that joins the collection of type product to the collection of type ProductCategory and return a collection of type ProductDto. Great so Let's go back to the product controller class and finish the code for GetItems action method. So in order for the convert to dto method to be accessible on the product variable. We must of course bring in the `ShopOnline.Api.Extensions` namespace. Then let's pass in the `ProductCategories` variable as an argument to the convert to dto extension method. Then we can return a http status code of 200 to the calling code. We can do this by returning the results of an ok method. Which accepts an argument of a collection of type ProductDto. So this code return a http status code of 200 as well as a collection of type productdto to the calling client code. So if for some reason an exception occurs during the running of the relavent server side code. In this case we want our code to return a http status code of 500 to the calling client code coupled with an appropriate error message. Let's keep the error message simple. Great so if we open our program.cs file. You can see the configuration code here related to `Swagger` and `SwaggerUI`. Swagger is an `interface description language` for describing restful apis expressed using `Json`. the configuration relevent to SwaggerUI here means that our web api project is equiped with a basic `web based user interface` where we can see relavent information regarding our `controller` and action methods. We are also able to use the swaggerUI to test and debug our action methods. When we run our web api code interactively through visual studio. So let's run our code to see this in action. And here we're presented with the SwaggerUI. Let's test our GetItems action method. We can do this through our swagger user interface like this. Excellent In the next part of this project We'll write the `calling client code` that calls the action method that we've written in this tutorial from our blazor component. We'll also write the code to appropriately display the products returned from our web api component to the user. So in the next part We'll start to develop our blazor WebAssembly Component. [HTTP request methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods) [Attributes (C#)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/attributes/) [Attribute Routing in ASP.NET Web API 2](https://docs.microsoft.com/en-us/aspnet/web-api/overview/web-api-routing-and-actions/attribute-routing-in-web-api-2) [try-catch (C# Reference)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/try-catch) [Retrieve resources in .NET apps](https://docs.microsoft.com/en-us/dotnet/core/extensions/retrieve-resources) [Introduction to LINQ Queries (C#)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/introduction-to-linq-queries) [Basic LINQ Query Operations (C#)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/basic-linq-query-operations) [Extension Methods (C# Programming Guide)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods) [EntityFrameworkQueryableExtensions.Include Method](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.entityframeworkqueryableextensions.include?view=efcore-6.0) [Query expression basics](https://docs.microsoft.com/en-us/dotnet/csharp/linq/query-expression-basics) [Jump statements (C# reference)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/jump-statements#the-return-statement) [Split queries](https://docs.microsoft.com/en-us/ef/core/querying/single-split-queries) [Efficient Querying](https://docs.microsoft.com/en-us/ef/core/performance/efficient-querying) [How to find the set difference between two lists (LINQ) (C#)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/how-to-find-the-set-difference-between-two-lists-linq) [C# program building blocks](https://docs.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/program-building-blocks) [Attributes (C#)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/attributes/) [Include(String) Method](https://docs.microsoft.com/en-us/dotnet/api/system.data.objects.objectquery-1.include?view=netframework-4.8) [Call a Web API From a .NET Client (C#)](https://docs.microsoft.com/en-us/aspnet/web-api/overview/advanced/calling-a-web-api-from-a-net-client)*

*[null (C# Reference)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/null) [Properties (C# Programming Guide)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/properties) [String.Join Method](https://docs.microsoft.com/en-us/dotnet/api/system.string.join?view=net-6.0) [Language Integrated Query (LINQ) (C#)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/) [static (C# Reference)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/static) [The C# type system](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/) [Convert Class](https://docs.microsoft.com/en-us/dotnet/api/system.convert?view=net-6.0) [How to convert a string to a number (C# Programming Guide)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/how-to-convert-a-string-to-a-number) [Exceptions and Exception Handling](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/exceptions/) [Configuration in .NET](https://docs.microsoft.com/en-us/dotnet/core/extensions/configuration) [SON serialization and deserialization (marshalling and unmarshalling) in .NET - overview](https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-overview?pivots=dotnet-6-0) [Build RESTful APIs with ASP.NET Web API](https://docs.microsoft.com/en-us/aspnet/web-api/overview/older-versions/build-restful-apis-with-aspnet-web-api) [Introduction to Microsoft Interface Definition Language 3.0](https://docs.microsoft.com/en-us/uwp/midl-3/intro) [Choose an ASP.NET Core web UI](https://docs.microsoft.com/en-us/aspnet/core/tutorials/choose-web-ui?view=aspnetcore-6.0) [Swagger UI](https://swagger.io/tools/swagger-ui/) [ASP.NET Core web API documentation with Swagger / OpenAPI](https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger?view=aspnetcore-6.0) [Walkthrough: Create and run unit tests for managed code](https://docs.microsoft.com/en-us/visualstudio/test/walkthrough-creating-and-running-unit-tests-for-managed-code?view=vs-2022) [Tutorial: Learn to debug C# code using Visual Studio](https://docs.microsoft.com/en-us/visualstudio/get-started/csharp/tutorial-debugger?view=vs-2022)* 
